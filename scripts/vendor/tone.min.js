(function(global){
  'use strict';
  const AudioContextClass = global.AudioContext || global.webkitAudioContext;
  const isSupported = !!AudioContextClass;
  const context = isSupported ? new AudioContextClass() : null;
  const masterGain = isSupported ? context.createGain() : null;
  if (masterGain) {
    masterGain.gain.value = 1;
    masterGain.connect(context.destination);
  }
  const dbToGain = db => Math.pow(10, db / 20);
  const toFrequency = value => {
    if (typeof value === 'number' && isFinite(value)) {
      return Math.max(1, value);
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (!trimmed) {
        return 440;
      }
      const hzMatch = trimmed.match(/^(\d+(?:\.\d+)?)\s*hz$/i);
      if (hzMatch) {
        return parseFloat(hzMatch[1]);
      }
      const noteMatch = trimmed.match(/^([a-gA-G])(#|b)?(\d)$/);
      if (noteMatch) {
        const baseMap = { C: -9, D: -7, E: -5, F: -4, G: -2, A: 0, B: 2 };
        const letter = noteMatch[1].toUpperCase();
        const accidental = noteMatch[2] === '#' ? 1 : noteMatch[2] === 'b' ? -1 : 0;
        const octave = parseInt(noteMatch[3], 10);
        const semitoneOffset = baseMap[letter] + accidental + (octave - 4) * 12;
        return 440 * Math.pow(2, semitoneOffset / 12);
      }
    }
    return 440;
  };
  class ToneGain {
    constructor(){
      if (!isSupported) {
        this.context = null;
        return;
      }
      this.context = context;
      this.node = context.createGain();
      this.node.gain.value = 1;
    }
    connect(destination){
      if (!this.node) {
        return this;
      }
      if (destination && typeof destination.input !== 'undefined') {
        this.node.connect(destination.input);
      } else if (destination && destination.node) {
        this.node.connect(destination.node);
      } else {
        this.node.connect(destination || masterGain);
      }
      return this;
    }
    disconnect(){
      if (this.node) {
        try {
          this.node.disconnect();
        } catch (error) {}
      }
      return this;
    }
  }
  class ToneVolume extends ToneGain {
    constructor(){
      super();
      this._value = 0;
      this.volume = this;
      this.updateGain();
    }
    get value(){
      return this._value;
    }
    set value(db){
      this._value = typeof db === 'number' ? db : 0;
      this.updateGain();
    }
    updateGain(){
      if (this.node) {
        this.node.gain.setValueAtTime(dbToGain(this._value), context.currentTime);
      }
    }
  }
  class Synth {
    constructor(options = {}){
      this.context = context;
      this.oscillator = null;
      this.output = new ToneVolume();
      this.output.connect(masterGain);
      const defaults = {
        oscillator: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0.6, release: 0.6 }
      };
      this.options = {
        oscillator: Object.assign({}, defaults.oscillator, options.oscillator || {}),
        envelope: Object.assign({}, defaults.envelope, options.envelope || {})
      };
      this.volume = this.output;
    }
    connect(destination){
      this.output.disconnect();
      this.output.connect(destination || masterGain);
      return this;
    }
    triggerAttackRelease(note, duration = 0.5, time){
      if (!isSupported || !this.output.node) {
        return;
      }
      const ctx = this.context;
      const startTime = typeof time === 'number' ? time : ctx.currentTime;
      const attack = Math.max(0, Number(this.options.envelope.attack) || 0.01);
      const decay = Math.max(0, Number(this.options.envelope.decay) || 0.1);
      const sustain = Math.max(0, Math.min(1, Number(this.options.envelope.sustain) || 0.6));
      const release = Math.max(0, Number(this.options.envelope.release) || 0.2);
      const totalDuration = Math.max(0.05, Number(duration) || 0.5);
      const oscillator = ctx.createOscillator();
      const envelopeGain = ctx.createGain();
      oscillator.type = this.options.oscillator.type || 'sine';
      oscillator.frequency.setValueAtTime(toFrequency(note), startTime);
      oscillator.connect(envelopeGain);
      envelopeGain.connect(this.output.node);
      const attackEnd = startTime + attack;
      const decayEnd = attackEnd + decay;
      const releaseStart = startTime + totalDuration;
      envelopeGain.gain.cancelScheduledValues(startTime);
      envelopeGain.gain.setValueAtTime(0.0001, startTime);
      envelopeGain.gain.linearRampToValueAtTime(1, attackEnd);
      envelopeGain.gain.linearRampToValueAtTime(sustain, decayEnd);
      envelopeGain.gain.setValueAtTime(sustain, releaseStart);
      envelopeGain.gain.linearRampToValueAtTime(0.0001, releaseStart + release);
      oscillator.start(startTime);
      oscillator.stop(releaseStart + release + 0.1);
      oscillator.onended = () => {
        try { oscillator.disconnect(); envelopeGain.disconnect(); } catch (error) {}
      };
      this.oscillator = oscillator;
    }
    dispose(){
      if (this.oscillator) {
        try {
          this.oscillator.stop();
          this.oscillator.disconnect();
        } catch (error) {}
      }
      this.output.disconnect();
    }
  }
  const Tone = {
    context,
    isSupported,
    Destination: masterGain,
    now: () => (context ? context.currentTime : 0),
    start: () => {
      if (!context) {
        return Promise.resolve();
      }
      if (context.state === 'running') {
        return Promise.resolve();
      }
      return context.resume ? context.resume() : Promise.resolve();
    },
    Synth
  };
  if (masterGain) {
    masterGain.volume = new ToneVolume();
  }
  global.Tone = Tone;
})(typeof window !== 'undefined' ? window : this);
